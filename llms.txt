=== README.md ===
# electron-agent-tools

Playwright-powered CLI and TypeScript helpers to launch, attach to, and drive Electron apps over CDP. Built for scripting, CI, and LLM agents with JSON-in/JSON-out commands.

## TL;DR
- Straightforward API to launch/quit the Electron app inside tests and drive the page with Playwright under the hood.
- All logs from every environment (stdout/stderr, renderer/preload/main, IPC, network) land in one `.e2e-artifacts/<prefix>/run.log` file à la [dev3000](https://github.com/vercel-labs/dev3000).
- Drop-in LLM context lives in `./llms.txt` so agents know how to use the tool immediately.

```
# .e2e-artifacts/last-run/run.log
[2025-11-23T11:37:46.637Z] [system]   [info]  run-start command=pnpm args=-w run start:debug
[2025-11-23T11:37:46.951Z] [stdout]   [info]  main-ready
[2025-11-23T11:37:47.182Z] [stderr]   [error] DevTools listening on ws://127.0.0.1:61831/devtools/browser/…
[2025-11-23T11:37:47.552Z] [renderer] [debug] [vite] connected url=http://localhost:5173/@vite/client
[2025-11-23T11:37:47.552Z] [preload]  [warn]  Electron Security Warning (Insecure CSP) url=node:electron/js2c/sandbox_bundle
[2025-11-23T11:37:47.517Z] [system]   [info]  cdp-ready wsUrl=ws://127.0.0.1:61831/devtools/browser/… pid=99426 electronPid=99445
[2025-11-23T11:37:48.037Z] [renderer] [log]   stageSelection click {"workspace":"/tmp/…","targetPath":"hunks.txt","hasSelectedPatch":true}
[2025-11-23T11:37:48.251Z] [ipc]      [info]  ipc-trace direction=renderer->main kind=invoke channel=eat-ping durationMs=4
[2025-11-23T11:37:48.350Z] [network]  [warn]  response>=400 url=http://localhost:5173/node_modules/.vite/deps/react-devtools line=0
[2025-11-23T11:37:49.257Z] [system]   [info]  run-end pid=99426 electronPid=99445
```

## What it does
- `browser-tools <subcmd>`: JSON-only CLI to click, type, wait, screenshot, dump DOM, and stream logs.
- `launch-electron start|quit`: spawn an Electron app with CDP enabled and collect artifacts.
- Tiny API: `connectAndPick(opts)` and `getWsUrl({ port })` wrap `chromium.connectOverCDP` and target selection.
- Unified logs: every run writes `.e2e-artifacts/<prefix>/run.log` containing stdout/stderr, renderer/preload/main console, IPC, network, and lifecycle lines.

## Quickstart
1) Install: `pnpm add -D electron-agent-tools`

### Using the CLI
2) Launch your app with CDP exposed:
```bash
E2E_CDP_PORT=9333 pnpm exec electron path/to/main.js &
```
3) Discover the debugger URL, then drive the app:
```bash
WS_URL=$(node -e "import { getWsUrl } from 'electron-agent-tools'; (async()=>console.log(await getWsUrl({ port: 9333 })))();")
npx browser-tools wait-text '{"wsUrl":"'"$WS_URL"'","text":"Open workspace"}'
npx browser-tools click '{"wsUrl":"'"$WS_URL"'","testid":"open-workspace-button"}'
npx browser-tools screenshot '{"wsUrl":"'"$WS_URL"'","path":".e2e-artifacts/smoke.png"}'
```
Artifacts land in `.e2e-artifacts/<timestamp>` with a `last-run` symlink for convenience.

### Using TypeScript
```ts
import { launchElectron, connectAndPick } from 'electron-agent-tools'

// Launch the app and get a ready-to-use CDP endpoint
const { wsUrl, quit } = await launchElectron({
  command: 'pnpm',
  args: ['exec', 'electron', 'fixtures/main.js'],
  headless: true,
})

// Drive it with Playwright under the hood
const driver = await connectAndPick({ wsUrl })
await driver.click({ testid: 'open-workspace-button' })
await driver.waitText('Open workspace')

// Clean shutdown (also kills the spawned Electron)
await quit()
```

Check `examples/` for a ready-to-run smoke test against the bundled fixture app.

## Debugging helpers
- **Unified run.log**: each run emits `[ISO] [source] [level] message` lines across stdout/stderr, console (renderer/preload/main/isolated), IPC traces, network failures, screenshots, and DOM dumps.
- **World-aware eval**: `driver.evalInPreload`, `evalInRendererMainWorld`, `evalInIsolatedWorld` let you probe exactly where globals live.
- **Lifecycle hooks**: `onRendererReload` / `onPreloadReady` plus `waitForBridge()` for contextIsolation + Vite reloads.
- **Polling helper**: `waitForValue(fn, { description?, timeoutMs?, pollMs?, context? })` keeps calling a renderer/main-world function until it returns a value, capturing the last error on timeout.
- **Deterministic injection**: `injectGlobals(obj, { persist: true })` replays helpers into renderer + preload on every navigation.
- **State snapshots**: `snapshotGlobals(['foo','bar'])`, `dumpDOM(selector?)`, and `waitForTextAcrossReloads` help debug flaky UIs.
- **DevTools in headless**: `getRendererInspectorUrl()` builds a `devtools://…` link for the current renderer target.

## Development
- `pnpm install`
- `pnpm build`
- `pnpm check`  # biome + typecheck
- `pnpm test`   # runs the examples against the fixture app (headless in CI)

## License
MIT

=== docs/api.md ===
# Electron Agent Tools API

Reference for everything the package exposes: the TypeScript library _and_ the JSON-only CLIs. Paths are repo-relative; when installed from npm use the published binaries (e.g., `npm exec browser-tools -- …`).

## Library (TypeScript / ESM)

Import surface (`src/index.ts`):

```ts
import { getWsUrl, connectAndPick, launchElectron, AppError, LaunchError } from 'electron-agent-tools'
import type {
  ConnectOptions,
  Selector,
  Driver,
  SnapshotPerWorld,
  LaunchOptions,
  LaunchResult,
  ArtifactOptions,
  AppErrorCode,
  LaunchErrorCode,
  ErrorCode,
} from 'electron-agent-tools'
```

### `getWsUrl({ port, timeoutMs? }): Promise<string>`
- Polls `http://127.0.0.1:<port>/json/version` until `webSocketDebuggerUrl` is available.
- Each poll request is aborted after ~1.5s so half-open ports can't stall the loop; overall timeout still applies.
- `timeoutMs` default: 30_000; rejects with an Error containing `details` on timeout.

### `launchElectron(opts: LaunchOptions): Promise<LaunchResult>`
- Spawns the Electron command, chooses/provides `cdpPort`, and waits for `wsUrl` before resolving.
- Streams stdout/stderr and lifecycle notices into `<artifactDir>/<artifactPrefix>/run.log` (`[ISO] [source] [level] message`).
- Returns `{ wsUrl, pid, cdpPort, artifactDir, runLogPath, launchFile?, quit }`; `quit()` terminates the spawned tree (POSIX: SIGINT/SIGTERM/SIGKILL to the process group; Windows: `taskkill /T`).
- Accepts `artifactDir` / `artifactPrefix` to align artifacts with CLI defaults.
- If the Electron process errors or exits before CDP becomes reachable, the promise rejects immediately with `LaunchError` code `E_SPAWN` (spawn error) or `E_EXIT_EARLY` (exit/close), including the exit `code`/`signal` and `runLogPath` in `details`.

### `connectAndPick(opts: ConnectOptions): Promise<Driver>`
- Uses `chromium.connectOverCDP` to attach to an already‑running Electron renderer.
- `ConnectOptions`:
  - `wsUrl` (string, required) — CDP websocket debugger URL (e.g. from `getWsUrl`).
  - `pick?: { titleContains?: string; urlIncludes?: string }` — optional scoring hints when multiple pages exist; scores also prefer `app://`, `file://`, and localhost origins.
  - `runLogPath?: string` — when provided, all console/network/ipc/system events stream into that text file (`run.log` recommended).
- Returns a `Driver` (below). The underlying Playwright `Page` is exposed as `driver.page` (optional).

### `Driver` methods
- `click(sel: Selector): Promise<void>` — Clicks the first match. Respects `timeoutMs` on the selector; throws `E_SELECTOR` on failure.
- `type(sel: Selector & { value: string; clearFirst?: boolean }): Promise<void>` — Optionally clears, then fills. Honors `timeoutMs`.
- `press(key: string, sel?: Selector): Promise<void>` — Press a key globally or scoped to a locator.
- `hover(sel: Selector): Promise<void>` — Moves pointer to selector.
- `scrollIntoView(sel: Selector): Promise<void>` — Calls `scrollIntoView` on the element.
- `upload(sel: Selector, filePath: string): Promise<void>` — Uses `setInputFiles` on the locator.
- `waitText(text: string, timeoutMs = 10_000): Promise<void>` — Waits for visible text (substring match) or throws `E_WAIT_TIMEOUT`.
- `screenshot(path: string, fullPage = true): Promise<void>` — Ensures parent dirs exist, then writes PNG.
- `dumpOuterHTML(truncateAt?: number): Promise<string>` — Returns document.outerHTML, optionally truncated.
- `listSelectors(max = 200): Promise<{ testIds; roles; texts; }>` — Gathers top selectors from the document for quick discovery.
- `waitForWindow(timeoutMs?: number, pick?: ConnectOptions['pick']): Promise<{ url; title }>` — Waits for an existing or newly opened window matching hints and rewires listeners to that page. Safe to call while multiple contexts exist; background timeouts are cancelled so no unhandled rejections leak.
- `switchWindow(pick: ConnectOptions['pick']): Promise<{ url; title }>` — Chooses a window by `titleContains` / `urlIncludes` hints.
- `evalInRendererMainWorld / evalInIsolatedWorld / evalInPreload` — CDP evaluate helpers scoped to the exact JS world.
- `onRendererReload` / `onPreloadReady` — Lifecycle hooks to re-register globals across Vite/navigations.
- `waitForBridge(timeoutMs?)` — Polls preload for `__eatBridgeReady__`/`__eatTestHarness__`.
- `waitForValue(fn, { timeoutMs?, pollMs?, description?, context? })` — Repeatedly evaluates `fn` (renderer main world by default, or `context: 'page'`) until it returns a non-nullish value; defaults: `timeoutMs=10_000`, `pollMs=200`; on timeout throws `E_WAIT_TIMEOUT` with the last error message recorded.
- `injectGlobals(globals, { persist?, worlds? })` — Deterministically replays helper objects into chosen worlds after reloads.
- `snapshotGlobals(names, { worlds? })` — Returns values per world for quick state inspection.
- `waitForTextAcrossReloads(text, { timeoutMs?, perAttemptTimeoutMs? })` — Retry-friendly wait that tolerates renderer reloads and captures DOM on failure.
- `dumpDOM(selector?, truncateAt?)` — Dumps `outerHTML` (optionally scoped) with url/title, used by wait helpers on timeout.
- `getRendererInspectorUrl()` — Builds a `devtools://…` URL pointing at the current renderer target for headless DevTools.
- `close(): Promise<void>` — Disconnects from the CDP session (leaves the Electron app running).

### `Selector` shape
- At least one of:
  - `testid: string` (data-testid)
  - `role: { role: string; name?: string }` (ARIA role; name can be string or regex compatible)
  - `text: string` (substring text match)
  - `css: string` (CSS selector)
- Optionals: `nth?: number` (0‑based), `timeoutMs?: number`.

### Logging
- All runtime signals stream to `run.log` (one per run, typically `<artifactDir>/<prefix>/run.log`) with lines shaped `[ISO8601-with-ms] [SOURCE] [LEVEL] message key=value...`.
- Sources include `stdout`, `stderr`, `main`, `renderer`, `preload`, `isolated`, `worker`, `network` (requestfailed + responses >= 400), `ipc` (renderer<->main traces), `system` (start/ready/quit), `screenshot`, and `domdump`.

### Notes
- Selectors are resolved with Playwright locators in priority order: testid → role → text → css; then `nth` is applied.
- Errors from driver methods are wrapped as `AppError` with a `code` (e.g., `E_SELECTOR`, `E_WAIT_TIMEOUT`, `E_FS`).
- Console harvesting tags worlds via CDP and still only records after the driver connects; attach early (or launch via `launchElectron`) to capture the earliest logs.

## CLI: `browser-tools`

Entry (npm install): `npm exec browser-tools -- <subcmd> '<json>'` (or `pnpm exec` / `yarn browser-tools`). All subcommands accept a single JSON argument; output is single-line JSON. On error: `{ ok: false, error: { code, message, details } }`. Invalid JSON now fails fast (exit code 1) with:

```json
{ "ok": false, "error": { "code": "E_BAD_JSON", "message": "Invalid JSON input", "details": { "rawArg": "{not json", "parseError": "Unexpected token n in JSON at position 1" } } }
```

Common input keys:
- `wsUrl` (string, required for most) — CDP websocket URL.
- `timeoutMs` — overrides default 10_000 for wait/click/type selectors.
- Selectors follow the `Selector` shape above.
- `artifactDir` / `artifactPrefix` (for artifact-producing commands: screenshot, dump-dom). If omitted, commands reuse `.e2e-artifacts/last-run` when present.

Subcommands
- `list-windows` — Input: `{ wsUrl }`. Output: `{ ok: true, data: { pages: [{ targetId, url, title }] } }`.
- `list-selectors` — Input: `{ wsUrl, max? }`. Output: same shape as driver `listSelectors`.
- `wait-text` — Input: `{ wsUrl, text, timeoutMs? }`. Output: `{ ok: true, data: { visible: true } }`.
- `click` — Input: `{ wsUrl, ...Selector }`. Output: `{ clicked: true }`.
- `type` — Input: `{ wsUrl, value, clearFirst?, ...Selector }`. Output: `{ typed: true }`.
- `press` — Input: `{ wsUrl, key, ...Selector? }`. Output: `{ pressed: "key" }`.
- `hover` — Input: `{ wsUrl, ...Selector }`. Output: `{ hovered: true }`.
- `scroll-into-view` — Input: `{ wsUrl, ...Selector }`. Output: `{ scrolled: true }`.
- `upload` — Input: `{ wsUrl, filePath, ...Selector }`. Output: `{ uploaded: "filePath" }`.
- `get-dom` — Input: `{ wsUrl, as: 'innerHTML' | 'textContent', ...Selector }`. Output: `{ value: string }`.
- `screenshot` — Input: `{ wsUrl, path?, fullPage? }` (default path `.e2e-artifacts/<prefix>/page.png`, reusing last-run when available). Output: `{ path }`.
- `snapshot-globals` — Input: `{ wsUrl, names: ["foo","bar"], worlds? }`. Output: `{ snapshots }` per world.
- `dump-dom` — Input: `{ wsUrl, selector?, truncateAt? }`. Writes `.e2e-artifacts/<prefix>/dom-dump.html`; Output: `{ html, url, title }` and logs a `domdump` line.
- `wait-for-window` — Input: `{ wsUrl, pick?, timeoutMs? }`. Output: `{ url, title }`.
- `switch-window` — Input: `{ wsUrl, pick }`. Output: `{ url, title }`.

### CLI: `launch-electron`
- `start|launch` — Input: `{ command, args?, cwd?, env?, headless?, cdpPort?, artifactDir?, artifactPrefix? }`. Output: `{ wsUrl, pid, electronPid, cdpPort, artifactDir, runLogPath, launchFile, quitHint }` (electronPid is resolved by scanning descendant command lines for the launched Electron binary/helpers, with a fallback to the root pid).
- `quit` — Input: `{ pid }` or `{ launchFile }`. Output: `{ quit: true, pid }`. Terminates the spawned process tree (POSIX via process-group signals; Windows via `taskkill /T`).
- Both `launch-electron` commands share the same strict JSON parsing; malformed args return the `E_BAD_JSON` shape above and exit code 1.

Artifacts
- CLI writes under `<artifactDir>/<artifactPrefix>/` (defaults `.e2e-artifacts/<unix-ts>/`) with filenames: `run.log`, `launch.json`, `page.png`, `dom-dump.html` (or custom path). A `last-run` symlink per dir points at the most recent run; subsequent commands reuse it when no prefix is given.

## Usage Recipes

- Discover a running app then drive it with the typed Driver:
```ts
const wsUrl = await getWsUrl({ port: 9451 })
const driver = await connectAndPick({ wsUrl })
await driver.waitText('Select a folder')
await driver.click({ testid: 'pick-folder' })
await driver.close()
```

`driver.close()` only detaches from the CDP session; the Electron process keeps running.

- Drive via CLI (pure JSON, good for shell/LLM):
```bash
WS_URL=$(node -e "import { getWsUrl } from 'electron-agent-tools'; (async () => console.log(await getWsUrl({ port: 9451 })))();")
npm exec browser-tools -- wait-text "{\"wsUrl\":\"$WS_URL\",\"text\":\"click button\"}"
npm exec browser-tools -- click "{\"wsUrl\":\"$WS_URL\",\"testid\":\"click-button\"}"
```
  - Substitute `pnpm exec` / `yarn browser-tools` if you use those managers.

## Error Conventions
- `AppError` (exported): `code` is one of `E_SELECTOR`, `E_NO_PAGE`, `E_WAIT_TIMEOUT`, `E_FS`, `E_INTERNAL`.
- `LaunchError` (exported): `code` is `E_SPAWN`, `E_EXIT_EARLY`, or `E_CDP_TIMEOUT`.
- `ErrorCode` (exported type) is the union of all library codes for easy narrowing.
- CLI always returns JSON; check `ok` boolean before consuming `data`.
- Recommended handling pattern:

```ts
try {
  await connectAndPick(...);
} catch (err) {
  if (err instanceof AppError || err instanceof LaunchError) {
    switch (err.code as ErrorCode) {
      case 'E_SELECTOR':
        // retry with a different locator, etc.
        break
      case 'E_EXIT_EARLY':
        // check stderrPath in err.details
        break
      default:
        throw err // rethrow unknown codes
    }
  }
  throw err
}
```

=== examples/dom-dump.mjs ===
import { spawn } from 'node:child_process'
import { writeFile } from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

import { connectAndPick, getWsUrl } from '../dist/index.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const launch = async () => {
  const port = 9334
  const child = spawn('pnpm', ['exec', 'electron', 'fixtures/main.js'], {
    cwd: path.join(__dirname, '..'),
    env: {
      ...process.env,
      E2E_CDP_PORT: String(port),
      E2E: '1',
      NODE_ENV: 'test',
      ELECTRON_ENABLE_LOGGING: '1',
    },
    stdio: 'ignore',
  })
  const wsUrl = await getWsUrl({ port, timeoutMs: 40_000 })
  return { child, wsUrl }
}

const main = async () => {
  const launchInfo = await launch()

  const driver = await connectAndPick({ wsUrl: launchInfo.wsUrl })
  const outerHTML = await driver.dumpOuterHTML(250_000)
  await writeFile('.e2e-artifacts/dom.html', outerHTML, 'utf-8')
  await driver.close()

  launchInfo.child.kill('SIGINT')
}

main()

=== examples/smoke.mjs ===
import { spawn } from 'node:child_process'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

import { connectAndPick, getWsUrl } from 'electron-agent-tools'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const main = async () => {
  const port = 9333
  const electronBin = path.join(__dirname, '..', 'node_modules/.bin/electron')
  const child = spawn(electronBin, [path.join(__dirname, '..', 'fixtures/main.js')], {
    cwd: path.join(__dirname, '..'),
    env: {
      ...process.env,
      E2E_CDP_PORT: String(port),
      E2E: '1',
      NODE_ENV: 'test',
      ELECTRON_ENABLE_LOGGING: '1',
    },
    stdio: 'ignore',
    detached: true,
  })

  // ensure child exits if parent exits
  const cleanup = () => {
    try {
      process.kill(-child.pid, 'SIGINT')
    } catch {
      /* ignore */
    }
  }
  process.on('exit', cleanup)
  process.on('SIGINT', cleanup)

  const wsUrl = await getWsUrl({ port, timeoutMs: 40_000 })
  const driver = await connectAndPick({ wsUrl })

  await driver.waitText('Open workspace', 20_000)
  await driver.click({ testid: 'open-workspace-button' })
  await driver.waitText('Select a folder', 20_000)
  await driver.screenshot('.e2e-artifacts/smoke.png', true)

  await driver.close()
  cleanup()
}

main()

=== examples/smoke.sh ===
#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT"

PORT=9355
E2E=1 NODE_ENV=test E2E_CDP_PORT=$PORT ELECTRON_ENABLE_LOGGING=1 pnpm exec electron fixtures/main.js &
APP_PID=$!
trap "kill $APP_PID 2>/dev/null || true" EXIT

WS_URL=$(node --input-type=module - <<'NODE'
import { getWsUrl } from './dist/index.js';
const ws = await getWsUrl({ port: 9355, timeoutMs: 40000 });
console.log(ws);
NODE
)

node "$ROOT/dist/cli/browser-tools.js" wait-text \
  "{\"wsUrl\":\"$WS_URL\",\"text\":\"click button\",\"timeoutMs\":20000}"

node "$ROOT/dist/cli/browser-tools.js" click \
  "{\"wsUrl\":\"$WS_URL\",\"testid\":\"click-button\"}"

node "$ROOT/dist/cli/browser-tools.js" wait-text \
  "{\"wsUrl\":\"$WS_URL\",\"text\":\"Select a folder\",\"timeoutMs\":20000}"

node "$ROOT/dist/cli/browser-tools.js" screenshot \
  "{\"wsUrl\":\"$WS_URL\",\"path\":\".e2e-artifacts/smoke.png\",\"fullPage\":true}"

=== src/cli/browser-tools.spec.mjs ===
import assert from 'node:assert'
import { execFile } from 'node:child_process'
import { access, mkdtemp, readdir, readFile, realpath, stat, writeFile } from 'node:fs/promises'
import os from 'node:os'
import path from 'node:path'
import { test } from 'node:test'
import { fileURLToPath, pathToFileURL } from 'node:url'
import { promisify } from 'node:util'

const execFileAsync = promisify(execFile)
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const root = path.join(__dirname, '..', '..')
const electronBin = (() => {
  if (process.platform === 'win32') {
    const exePath = path.join(root, 'node_modules', 'electron', 'dist', 'electron.exe')
    return exePath
  }
  return path.join(root, 'node_modules/.bin/electron')
})()
const pnpmBin = process.platform === 'win32' ? 'pnpm.cmd' : 'pnpm'

let built = false
const buildOnce = async () => {
  if (built) return
  await execFileAsync(pnpmBin, ['build'], {
    cwd: root,
    env: { ...process.env, NODE_ENV: 'test' },
    shell: process.platform === 'win32', // Node 20+: .cmd requires shell on Windows
  })
  built = true
}

const run = async (cmd, args, opts = {}) =>
  execFileAsync(cmd, args, {
    cwd: root,
    env: { ...process.env, NODE_ENV: 'test' },
    ...opts,
  })

const findLatestArtifact = async (filename, dir = '.e2e-artifacts') => {
  const artifactRoot = path.join(root, dir)
  const entries = await readdir(artifactRoot).catch(() => [])
  let latestPath = null
  let latestMtime = 0
  for (const entry of entries) {
    const candidate = path.join(artifactRoot, entry, filename)
    try {
      const st = await stat(candidate)
      if (st.isFile() && st.mtimeMs > latestMtime) {
        latestMtime = st.mtimeMs
        latestPath = candidate
      }
    } catch {
      // ignore
    }
  }
  return latestPath
}

const runBrowserTool = (sub, payload) =>
  run('node', [path.join(root, 'dist/cli/browser-tools.js'), sub, JSON.stringify(payload)]).then(
    (res) => JSON.parse(res.stdout),
  )

const loadLib = () => import(pathToFileURL(path.join(root, 'dist/index.js')).href)

test(
  'browser-tools subcommands, artifacts, and window helpers',
  { concurrency: false },
  async () => {
    await buildOnce()
    const { launchElectron, connectAndPick } = await loadLib()
    const disposables = []

    try {
      const launch = await launchElectron({
        command: electronBin,
        args: [path.join(root, 'fixtures/main.js')],
        artifactPrefix: 'cli-spec',
      })
      disposables.push(() => launch.quit())

      const wsUrl = launch.wsUrl

      // wait-text and click
      await runBrowserTool('wait-text', { wsUrl, text: 'click button', timeoutMs: 15000 })
      await runBrowserTool('click', { wsUrl, testid: 'click-button' })
      await runBrowserTool('wait-text', { wsUrl, text: 'Select a folder', timeoutMs: 15000 })

      // type + press enter on input
      await runBrowserTool('type', {
        wsUrl,
        testid: 'name-input',
        value: 'hello',
        clearFirst: true,
      })
      await runBrowserTool('press', { wsUrl, key: 'Enter', testid: 'name-input' })
      await runBrowserTool('wait-text', { wsUrl, text: 'pressed enter', timeoutMs: 10000 })

      // hover updates text
      await runBrowserTool('hover', { wsUrl, testid: 'hover-target' })
      await runBrowserTool('wait-text', { wsUrl, text: 'hovered', timeoutMs: 10000 })

      // list-windows
      const windows = await runBrowserTool('list-windows', { wsUrl })
      assert.ok(windows.ok, `list-windows failed: ${JSON.stringify(windows)}`)
      assert.ok(windows.data.pages.length >= 1)

      // list-selectors
      const selectors = await runBrowserTool('list-selectors', { wsUrl })
      assert.ok(selectors.data.testIds.includes('click-button'))

      // screenshot artifact (defaults to run dir)
      await runBrowserTool('screenshot', { wsUrl, fullPage: true })
      await access(path.join(root, '.e2e-artifacts/cli-spec/page.png'))

      // scroll into view sets scroll-status
      await runBrowserTool('scroll-into-view', { wsUrl, testid: 'far-target' })
      const scrollStatus = await runBrowserTool('get-dom', {
        wsUrl,
        css: '#scroll-status',
        as: 'textContent',
      })
      assert.strictEqual(scrollStatus.data.value.trim(), 'scrolled')

      // upload
      const tmpDir = await mkdtemp(path.join(os.tmpdir(), 'e2e-'))
      const uploadFile = path.join(tmpDir, 'upload.txt')
      await writeFile(uploadFile, 'hello')
      await runBrowserTool('upload', { wsUrl, testid: 'file-input', filePath: uploadFile })
      const uploadEcho = await runBrowserTool('get-dom', {
        wsUrl,
        testid: 'file-output',
        as: 'textContent',
      })
      assert.strictEqual(uploadEcho.data.value.trim(), 'upload.txt')

      // open new window and switch to it
      await runBrowserTool('click', { wsUrl, testid: 'open-window' })
      const waited = await runBrowserTool('wait-for-window', {
        wsUrl,
        pick: { titleContains: 'Second' },
        timeoutMs: 15000,
      })
      assert.ok(waited.data.url.includes('second.html'))

      const switched = await runBrowserTool('switch-window', {
        wsUrl,
        pick: { titleContains: 'Second' },
      })
      assert.ok(switched.data.title.includes('Second'))

      // dump-dom artifact
      const domDump = await runBrowserTool('dump-dom', { wsUrl, selector: '#title' })
      assert.strictEqual(domDump.ok, true)

      // world-aware helpers and tracing
      const driver = await connectAndPick({
        wsUrl,
        pick: { titleContains: 'Mini' },
        runLogPath: launch.runLogPath,
      })
      disposables.push(() => driver.close())
      const bridgeProbe = await driver.evalInRendererMainWorld(() => ({
        ready: Boolean(globalThis.__eatBridgeReady__),
        hasBridge: Boolean(globalThis.eatBridge),
      }))
      assert.deepStrictEqual(bridgeProbe, { ready: true, hasBridge: true })
      await driver.waitForBridge(20000)

      await driver.injectGlobals({ injectedFoo: 'bar' }, { persist: true })
      const snapshots = await driver.snapshotGlobals(['injectedFoo', 'preloadMarker'], {
        worlds: ['renderer', 'preload', 'isolated'],
      })
      const rendererSnap = snapshots.find((s) => s.world === 'renderer')
      assert.strictEqual(rendererSnap?.values?.injectedFoo, 'bar')
      const markerWorlds = snapshots.filter(
        (s) => s.values && s.values.preloadMarker === 'from-preload',
      )
      assert.ok(markerWorlds.length >= 1, 'preloadMarker captured in at least one world')

      await driver.evalInRendererMainWorld(() => console.log('renderer-log-marker'))
      await driver.evalInPreload(() => console.log('preload-log-marker'))

      await driver.evalInPreload((msg) => globalThis.eatPing(msg), 'hello-trace')
      await driver.evalInRendererMainWorld(() =>
        fetch('http://127.0.0.1:0/e2e-log').catch(() => 'failed'),
      )

      const inspectorUrl = await driver.getRendererInspectorUrl()
      assert.ok(inspectorUrl.startsWith('devtools://'))

      // reload-friendly wait
      await driver.evalInRendererMainWorld(() => window.location.reload())
      await driver.waitForTextAcrossReloads('click button', {
        timeoutMs: 15000,
        perAttemptTimeoutMs: 5000,
      })

      // CLI snapshot + IPC harvest
      const snapshotCli = await runBrowserTool('snapshot-globals', {
        wsUrl,
        names: ['injectedFoo'],
      })
      assert.strictEqual(snapshotCli.ok, true)

      // confirm artifacts exist under run dir
      const domDumpFile = await findLatestArtifact('dom-dump.html')
      assert.ok(domDumpFile, 'dom-dump artifact present')

      await new Promise((resolve) => setTimeout(resolve, 500))
      const runLog = await readFile(launch.runLogPath, 'utf-8')
      assert.match(runLog, /\[system\] \[info\] run-start/, 'run-start logged')
      assert.match(runLog, /\[stdout\] \[info\].*main-ready/, 'stdout captured')
      assert.match(
        runLog,
        /\[(preload|renderer)\] \[(log|info)\].*preload-ready/,
        'preload console captured',
      )
      assert.match(
        runLog,
        /\[renderer\] \[(log|info)\].*fixture-loaded/,
        'renderer console captured',
      )
      assert.match(runLog, /\[ipc\] \[info\].*eat-ping/, 'ipc trace captured')
      assert.match(runLog, /\[network\] \[warn\].*e2e-log/, 'network events captured')
      assert.match(runLog, /\[screenshot\] \[info\].*page\.png/, 'screenshot logged')
      assert.match(runLog, /\[domdump\] \[info\].*dom-dump/, 'dom dump logged')

      const lastRun = path.join(root, '.e2e-artifacts/last-run')
      const lastRunTarget = await realpath(lastRun)
      assert.strictEqual(
        lastRunTarget,
        path.resolve(launch.artifactDir),
        'last-run points to run dir',
      )
      await access(path.join(lastRunTarget, 'dom-dump.html'))
    } finally {
      for (const dispose of disposables.reverse()) {
        try {
          await dispose()
        } catch {
          // ignore cleanup errors
        }
      }
    }
  },
)

test('launch-electron CLI start/quit', { concurrency: false }, async () => {
  await buildOnce()

  const payload = {
    command: electronBin,
    args: [path.join(root, 'fixtures/main.js')],
    artifactPrefix: 'cli-launch',
  }

  const start = await run('node', [
    path.join(root, 'dist/cli/launch-electron.js'),
    'start',
    JSON.stringify(payload),
  ])
  const startJson = JSON.parse(start.stdout)
  assert.strictEqual(startJson.ok, true)
  assert.ok(startJson.data.wsUrl)
  assert.ok(startJson.data.pid)

  const quit = await run('node', [
    path.join(root, 'dist/cli/launch-electron.js'),
    'quit',
    JSON.stringify({
      launchFile: startJson.data.launchFile,
      pid: startJson.data.electronPid ?? startJson.data.pid,
    }),
  ])
  const quitJson = JSON.parse(quit.stdout)
  assert.strictEqual(quitJson.ok, true)
})

=== src/lib/launch-electron.spec.mjs ===
import assert from 'node:assert'
import { readdir } from 'node:fs/promises'
import path from 'node:path'
import { test } from 'node:test'
import { fileURLToPath, pathToFileURL } from 'node:url'
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const root = path.join(__dirname, '..', '..')
const electronBin = (() => {
  if (process.platform === 'win32') {
    return path.join(root, 'node_modules', 'electron', 'dist', 'electron.exe')
  }
  return path.join(root, 'node_modules/.bin/electron')
})()
const loadLib = () => import(pathToFileURL(path.join(root, 'dist/index.js')).href)

const countFds = async () => {
  const candidates = ['/proc/self/fd', '/dev/fd']
  for (const dir of candidates) {
    try {
      const entries = await readdir(dir)
      const numeric = entries.filter((e) => /^\d+$/.test(e))
      if (numeric.length) return numeric.length
    } catch {
      // try next
    }
  }
  return -1 // signal unsupported environment
}

test(
  'launchElectron closes log file descriptors between runs',
  { concurrency: false },
  async () => {
    const { launchElectron } = await loadLib()

    const before = await countFds()

    for (let i = 0; i < 4; i += 1) {
      const launch = await launchElectron({
        command: electronBin,
        args: [path.join(root, 'fixtures/main.js')],
        artifactPrefix: `fd-leak-${i}`,
        headless: true,
      })
      await launch.quit()
    }

    const after = await countFds()

    if (before !== -1 && after !== -1) {
      assert.ok(after <= before + 2, `fd count grew unexpectedly: before=${before}, after=${after}`)
    }
  },
)

=== src/lib/wait-for-value.spec.mjs ===
import assert from 'node:assert'
import path from 'node:path'
import { test } from 'node:test'
import { fileURLToPath, pathToFileURL } from 'node:url'
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const root = path.join(__dirname, '..', '..')
const { AppError, PlaywrightDriver } = await import(
  pathToFileURL(path.join(root, 'dist/lib/playwright-driver.js')).href
)

const createDriver = () => {
  const fakeBrowser = {} // not used by waitForValue when context === 'page'
  const fakePage = {
    // mirrors the Playwright Page evaluate signature the helper expects
    async evaluate(fn) {
      return typeof fn === 'function' ? await fn() : fn
    },
  }

  // @ts-expect-error minimal fakes: waitForValue only needs page.evaluate
  return new PlaywrightDriver(fakeBrowser, fakePage, 'ws://dummy', null)
}

test('waitForValue resolves once fn returns non-nullish', async () => {
  const driver = createDriver()
  let attempts = 0

  const value = await driver.waitForValue(
    () => {
      attempts += 1
      return attempts >= 3 ? 'ready' : null
    },
    { context: 'page', pollMs: 5, timeoutMs: 200 },
  )

  assert.strictEqual(value, 'ready')
  assert.strictEqual(attempts, 3)
})

test('waitForValue captures last error message on timeout', async () => {
  const driver = createDriver()
  let attempts = 0

  await assert.rejects(
    driver.waitForValue(
      () => {
        attempts += 1
        throw new Error('boom')
      },
      { context: 'page', pollMs: 5, timeoutMs: 40, description: 'boom test' },
    ),
    (err) => {
      assert.ok(err instanceof AppError)
      assert.strictEqual(err.code, 'E_WAIT_TIMEOUT')
      assert.strictEqual(err.details?.lastError, 'boom')
      assert.strictEqual(err.details?.description, 'boom test')
      assert.ok(attempts > 1, 'should retry after errors')
      return true
    },
  )
})
